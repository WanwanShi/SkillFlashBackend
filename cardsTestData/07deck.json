[
  {
    "Q": "What is React Native, and how does it differ from traditional mobile development? ",
    "A": "React Native is a framework for building native mobile apps using JavaScript. It allows developers to create mobile applications for iOS and Android using React and native platform capabilities, providing a native user experience without requiring native language expertise. (Source: React Native Documentation)",
    "tag": "react-native",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does React Native's architecture enable the creation of native mobile apps with JavaScript?",
    "A": "React Native utilizes a JavaScript thread that communicates with native threads via asynchronous, platform-specific code. This architecture allows for the combination of JavaScript's flexibility with native platform capabilities, resulting in high-performance, truly native mobile applications. (Source: React Native Architecture)",
    "tag": "react-native",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "Explain React Native's component-based structure and how it facilitates code reuse and maintenance.",
    "A": "React Native follows a component-based architecture, where UI elements are built using reusable components. These components encapsulate functionality and styling, promoting modular and maintainable code. The use of JavaScript and React's declarative syntax further enhances code reuse and simplifies maintenance. (Source: React Native Documentation)",
    "tag": "react-native",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is 'Expo' in the context of React Native, and what benefits does it offer? ",
    "A": "Expo is a development toolkit and platform for React Native applications. It provides a streamlined environment with pre-configured settings, offering a rich set of APIs and tools for faster development and easier deployment. With Expo, developers can build, deploy, and publish React Native apps without needing native development environments. (Source: Expo Documentation)",
    "tag": "react-native",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does React Native compare to other cross-platform mobile development frameworks like Flutter or Xamarin?",
    "A": "React Native, Flutter, and Xamarin all offer cross-platform mobile development solutions. React Native utilizes JavaScript and native components, providing a flexible and widely adopted option. Flutter uses Dart and a unique rendering engine, offering faster performance. Xamarin uses C# and provides direct access to native APIs, catering to native-like performance. (Source: Cross-Platform Frameworks Comparison)",
    "tag": "react-native",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is Java, and why is it considered an object-oriented language? ",
    "A": "Java is a high-level, object-oriented programming language designed to be platform-independent. It achieves OOP through features like encapsulation, inheritance, and polymorphism, and it compiles to bytecode that can run on any Java Virtual Machine, ensuring portability. (Source: Java Documentation)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does Java handle memory management and garbage collection? ",
    "A": "Java uses an automatic garbage collector to manage memory allocation and deallocation. The garbage collector identifies and reclaims memory occupied by objects that are no longer reachable or in use, freeing developers from the burden of manual memory management. (Source: Java Memory Management)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "Explain the concept of 'platform independence' in Java and how it is achieved.",
    "A": "Platform independence in Java refers to the ability to write and run code on various operating systems without modification. This is achieved through the use of bytecode, which is platform-neutral, and the Java Virtual Machine (JVM), which interprets and executes the bytecode on specific platforms. (Source: Java Platform Independence)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is TypeScript, and why was it created? ",
    "A": "TypeScript is a strongly typed superset of JavaScript that adds type-checking at compile time. It was created to address the challenges of building large-scale JavaScript applications by providing static typing, improved tooling, and enhanced language features. (Source: TypeScript Handbook)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does TypeScript improve developer productivity and code quality? ",
    "A": "TypeScript catches type-related errors early in the development process, reducing runtime errors. It also enables better tooling support, such as auto-completion, refactoring, and code navigation, leading to improved developer productivity and overall code quality. (Source: TypeScript Documentation)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "Explain the concept of 'type inference' in TypeScript and how it reduces the need for explicit type annotations.",
    "A": "Type inference in TypeScript allows the compiler to automatically deduce the type of a variable or function based on its value or implementation. This eliminates the need for explicit type annotations, reducing verbosity and improving code readability. (Source: TypeScript Type Inference)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does TypeScript handle compatibility with existing JavaScript code and libraries? ",
    "A": "TypeScript is designed to be compatible with existing JavaScript code and libraries. It allows for gradual type checking and provides declaration files (d.ts) to describe the types of external JavaScript code, enabling seamless integration with existing JavaScript ecosystems. (Source: TypeScript Handbook)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is the difference between a 'type' and an 'interface' in TypeScript? ",
    "A": "In TypeScript, a 'type' is used to define a type alias or a union/intersection of types. It is a way to give a name to a type and can be used anywhere a type is expected. An 'interface' defines the shape of an object and specifies which members it must contain, providing a way to enforce consistency across objects. (Source: TypeScript Handbook)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does TypeScript handle generics, and what benefits do they provide? ",
    "A": "TypeScript supports generics, which allow the creation of flexible, reusable functions and types that can work with different types. Generics improve code modularity, enable type safety, and reduce the need for type casting, making code more robust and easier to maintain. (Source: TypeScript Generics)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is the role of decorators in TypeScript, and how do they extend the functionality of classes and functions? ",
    "A": "Decorators in TypeScript are a way to modify or extend the behavior of classes, methods, or properties at design time. They provide a declarative way to add metadata or aspect-oriented programming features, allowing for more concise and reusable code. (Source: TypeScript Decorators)",
    "tag": "typescript",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does Java handle multithreading and concurrency? ",
    "A": "Java provides built-in support for multithreading through threads and the Thread class. It also offers higher-level concurrency tools like the Executor Framework and the java.util.concurrent package, which include thread pools, locks, and synchronization mechanisms for managing concurrent access and avoiding race conditions. (Source: Java Concurrency)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "Explain the concept of 'pass-by-value' and 'pass-by-reference' in Java, and provide examples of when to use each. ",
    "A": "In Java, primitive data types are passed by value, meaning a copy of the value is passed. Non-primitive data types (objects) are passed by reference, meaning a copy of the reference (memory address) is passed. 'Pass-by-value' is used for immutable types, while 'pass-by-reference' is used for mutable types to avoid unnecessary copying. (Source: Java Pass-by-Value vs Pass-by-Reference)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is the difference between 'checked exceptions' and 'unchecked exceptions' in Java? ",
    "A": "Checked exceptions are exceptions that the compiler requires you to handle or declare. They are typically used for expected, recoverable errors. Unchecked exceptions are not checked by the compiler and are generally used for unexpected, unrecoverable errors or programming errors. (Source: Java Checked vs Unchecked Exceptions)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "How does Java handle versioning and backward compatibility? ",
    "A": "Java maintains backward compatibility by ensuring that newer versions of the language and libraries do not break existing code. This is achieved through strict versioning practices, deprecation policies, and the use of module systems like Java Platform Module System (JPMS) to isolate and manage dependencies. (Source: Java Versioning)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627692
  },
  {
    "Q": "What is the difference between 'Overloading' and 'Overriding' in Java? ",
    "A": "Overloading in Java refers to multiple methods in the same class having the same name but different parameter types. Overriding occurs when a subclass provides its own implementation of a method defined in its superclass. Overloading is about method signatures, while overriding is about inheritance and polymorphism. (Source: Java Overloading vs Overriding)",
    "tag": "java",
    "Y": 0,
    "N": 0,
    "card_id": 1716193627693
  }
]
